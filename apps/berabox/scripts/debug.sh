#!/bin/bash
set -euo pipefail

# Berabox Debug Configuration Generator
# Generates debug configurations for VS Code to connect to debug ports

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
BERABOX_ROOT="$(dirname "$SCRIPT_DIR")"

# Source common functions
source "$SCRIPT_DIR/common.sh"
source "$SCRIPT_DIR/arg-builder.sh"

# Configuration
DEBUG_DIR="$BERABOX_ROOT/debug"
GRAFANA_DIR="$DEBUG_DIR/grafana"
PROMETHEUS_DIR="$DEBUG_DIR/prometheus"
VSCODE_DIR=".vscode"

# Configuration - use default installations directory
INSTALLATIONS_DIR="${BB_CONFIG_INSTALLATIONS_DIR:-$BERABOX_ROOT/installations}"

# Validate installations directory
if [[ ! -d "$INSTALLATIONS_DIR" ]]; then
    log_error "Installations directory not found: $INSTALLATIONS_DIR"
    exit 1
fi



# Create debug directory structure
create_debug_dirs() {
    log_step "Creating debug directory structure..."
    bb_ensure_directory "$DEBUG_DIR"
    bb_ensure_directory "$GRAFANA_DIR"
    bb_ensure_directory "$PROMETHEUS_DIR"
    bb_ensure_directory "$VSCODE_DIR"
}

# Function to get installation info using common.sh functions
get_installation_info() {
    local installation="$1"
    local toml_file="$INSTALLATIONS_DIR/$installation/installation.toml"
    
    if [[ ! -f "$toml_file" ]]; then
        return 1
    fi
    
    # Parse basic info using common.sh function
    local chain=$(bb_parse_toml_value "$toml_file" "chain" || echo "unknown")
    local el_client=$(bb_parse_toml_value "$toml_file" "el_client" || echo "unknown")
    
    echo "$installation|$chain|$el_client"
}

# Function to get installation ports using common.sh functions
get_installation_ports() {
    local installation="$1"
    local toml_file="$INSTALLATIONS_DIR/$installation/installation.toml"
    
    if [[ ! -f "$toml_file" ]]; then
        return 1
    fi
    
    # Parse ports using common.sh function
    local cl_prometheus_port=$(bb_parse_toml_value "$toml_file" "cl_prometheus_port" || echo "0")
    local el_prometheus_port=$(bb_parse_toml_value "$toml_file" "el_prometheus_port" || echo "0")
    
    echo "$cl_prometheus_port|$el_prometheus_port"
}


# Generate Prometheus configuration
generate_prometheus_config() {
    log_step "Generating Prometheus configuration..."
    
    local prometheus_yml="$PROMETHEUS_DIR/prometheus.yml"
    
    cat > "$prometheus_yml" << 'EOF'
# Berabox Prometheus Configuration
# Auto-generated by debug command - DO NOT EDIT MANUALLY

global:
  scrape_interval: 15s
  evaluation_interval: 15s
  external_labels:
    monitor: 'berabox'
    environment: 'development'

rule_files:
  # Add rule files here as needed

scrape_configs:
  # Prometheus itself
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  # System metrics
  - job_name: 'node-exporter'
    static_configs:
      - targets: ['localhost:9100']

EOF

    # Find all installations
    local installations=()
    for dir in "$INSTALLATIONS_DIR"/*; do
        if [[ -d "$dir" && -f "$dir/installation.toml" ]]; then
            local name=$(basename "$dir")
            installations+=("$name")
        fi
    done
    
    # Generate CL targets
    echo "  # =======================================================" >> "$prometheus_yml"
    echo "  # Berabox Consensus Layer (Beacon-Kit) Services" >> "$prometheus_yml"
    echo "  # =======================================================" >> "$prometheus_yml"
    echo "" >> "$prometheus_yml"
    
    for installation in "${installations[@]}"; do
        local info=$(get_installation_info "$installation")
        if [[ -n "$info" ]]; then
            IFS='|' read -r name chain client <<< "$info"
            local ports=$(get_installation_ports "$installation")
            IFS='|' read -r cl_port el_port <<< "$ports"
            
            if [[ "$cl_port" != "0" ]]; then
                cat >> "$prometheus_yml" << EOF
  # $name CL
  - job_name: 'berabox-$name-cl'
    static_configs:
      - targets: ['localhost:$cl_port']
        labels:
          service: 'berachain-node'
          component: 'consensus-layer'
          installation: '$name'
          chain: '$chain'
          client: 'beacon-kit'

EOF
            fi
        fi
    done
    
    # Generate EL targets
    echo "  # =======================================================" >> "$prometheus_yml"
    echo "  # Berabox Execution Layer Services" >> "$prometheus_yml"
    echo "  # =======================================================" >> "$prometheus_yml"
    echo "" >> "$prometheus_yml"
    
    for installation in "${installations[@]}"; do
        local info=$(get_installation_info "$installation")
        if [[ -n "$info" ]]; then
            IFS='|' read -r name chain el_client <<< "$info"
            local ports=$(get_installation_ports "$installation")
            IFS='|' read -r cl_port el_port <<< "$ports"
            
            if [[ "$el_port" != "0" ]]; then
                # Determine metrics path based on client type
                local metrics_path="/metrics"
                if [[ "$el_client" == "geth" ]]; then
                    metrics_path="/debug/metrics/prometheus"
                fi
                
                cat >> "$prometheus_yml" << EOF
  # $name EL (uses $metrics_path)
  - job_name: 'berabox-$name-el'
    metrics_path: $metrics_path
    static_configs:
      - targets: ['localhost:$el_port']
        labels:
          service: 'berachain-node'
          component: 'execution-layer'
          installation: '$name'
          chain: '$chain'
          client: '$el_client'

EOF
            fi
        fi
    done
    
    log_info "‚úì Prometheus configuration generated: $prometheus_yml"
}


# Disable beacon-kit .vscode directories to prevent task pollution
disable_subproject_vscode_configs() {
    log_step "Disabling beacon-kit .vscode configurations..."
    
    # Find and rename problematic .vscode directories
    while IFS= read -r -d '' vscode_dir; do
        if [[ -d "$vscode_dir" ]]; then
            local disabled_dir="${vscode_dir}.disabled-by-berabox"
            mv "$vscode_dir" "$disabled_dir"
            log_info "‚úì Disabled: $(basename "$(dirname "$vscode_dir")")/.vscode"
        fi
    done < <(find "$BERABOX_ROOT/installations" -path "*/src/beacon-kit/.vscode" -type d -print0 2>/dev/null)
}

# Generate VS Code workspace file
generate_vscode_workspace() {
    log_step "Generating VS Code workspace..."
    
    local workspace_file="$BERABOX_ROOT/bb-berabox.code-workspace"
    
    # Start workspace JSON
    cat > "$workspace_file" << 'EOF'
{
    "folders": [
        {
            "name": "üéØ BeraBox Root",
            "path": "."
        }
EOF

    # Add installation folders
    local installations=()
    for dir in "$INSTALLATIONS_DIR"/*; do
        if [[ -d "$dir" && -f "$dir/installation.toml" ]]; then
            local name=$(basename "$dir")
            installations+=("$name")
        fi
    done
    
    # Add source code folders for each installation
    for installation in "${installations[@]}"; do
        local info=$(get_installation_info "$installation")
        if [[ -n "$info" ]]; then
            IFS='|' read -r name chain el_client <<< "$info"
            
            # Add beacon-kit source
            if [[ -d "$INSTALLATIONS_DIR/$installation/src/beacon-kit" ]]; then
                cat >> "$workspace_file" << EOF
        ,{
            "name": "CL $name - Beacon-Kit (CL)",
            "path": "./installations/$installation/src/beacon-kit"
        }
EOF
            fi
            
            # Add EL client source
            local el_src_dir=""
            if [[ "$el_client" == "reth" && -d "$INSTALLATIONS_DIR/$installation/src/bera-reth" ]]; then
                el_src_dir="bera-reth"
            elif [[ "$el_client" == "geth" && -d "$INSTALLATIONS_DIR/$installation/src/bera-geth" ]]; then
                el_src_dir="bera-geth"
            fi
            
            if [[ -n "$el_src_dir" ]]; then
                cat >> "$workspace_file" << EOF
        ,{
            "name": "EL $name - $el_client (EL)",
            "path": "./installations/$installation/src/$el_src_dir"
        }
EOF
            fi
        fi
    done
    
    # Close workspace JSON with settings and launch config reference
    cat >> "$workspace_file" << EOF
    ],
    "settings": {
        "go.toolsManagement.checkForUpdates": "local",
        "go.useLanguageServer": true,
        "rust-analyzer.cargo.features": "all",
        "rust-analyzer.checkOnSave.command": "clippy",
        "search.useIgnoreFiles": true,
        "search.exclude": {
            "**/installations/*/data/**": true,
            "**/installations/*/logs/**": true,
            "**/installations/*/runtime/**": true,
            "**/installations/*/systemd/**": true,
            "**/installations/*/src/**/target/**": true
        },
        "files.exclude": {
            "**/installations/*/data/**": true,
            "**/installations/*/logs/**": true,
            "**/installations/*/runtime/**": true,
            "**/installations/*/systemd/**": true,
            "**/installations/*/src/**/target/**": true
        },
        "files.watcherExclude": {
            "**/installations/*/data/**": true,
            "**/installations/*/logs/**": true,
            "**/installations/*/runtime/**": true,
            "**/installations/*/systemd/**": true,
            "**/installations/*/src/**/target/**": true
        }
    },
    "launch": {
        "version": "0.2.0",
        "configurations": [],
        "compounds": []
    },
    "extensions": {
        "recommendations": [
            "golang.go",
            "rust-lang.rust-analyzer", 
            "ms-vscode.cpptools",
            "vadimcn.vscode-lldb"
        ]
    }
}
EOF

    log_info "‚úì VS Code workspace generated: $workspace_file"
}

# Generate VS Code launch configurations
generate_vscode_launch_configs() {
    log_step "Generating VS Code launch configurations..."
    
    # Create .vscode directory in berabox root
    local vscode_root_dir="$VSCODE_DIR"
    bb_ensure_directory "$vscode_root_dir"
    local launch_json="$vscode_root_dir/launch.json"
    
    # Start launch.json
    cat > "$launch_json" << 'EOF'
{
    "version": "0.2.0",
    "configurations": [
EOF

    # Find all installations
    local installations=()
    for dir in "$INSTALLATIONS_DIR"/*; do
        if [[ -d "$dir" && -f "$dir/installation.toml" ]]; then
            local name=$(basename "$dir")
            installations+=("$name")
        fi
    done
    
    local first_config=true
    
    # Generate configurations for each installation
    for installation in "${installations[@]}"; do
        local info=$(get_installation_info "$installation")
        if [[ -n "$info" ]]; then
            IFS='|' read -r name chain el_client <<< "$info"
            local installation_dir="$INSTALLATIONS_DIR/$installation"
            
            # Add comma separator for subsequent configs
            if [[ "$first_config" == "false" ]]; then
                echo "," >> "$launch_json"
            fi
            first_config=false
            
            # Get actual CL PID from systemd if service is running
            local cl_pid=""
            if systemctl --user is-active "$name-cl.service" >/dev/null 2>&1; then
                cl_pid=$(systemctl --user show "$name-cl.service" --property=MainPID --value 2>/dev/null | tr -d '\n\r ')
                log_info "Found CL PID for $name: $cl_pid"
            else
                log_info "No active CL service found for $name"
            fi
            
            # CL (Beacon-Kit) Debug Configurations - Attach to process
            if [[ -n "$cl_pid" && "$cl_pid" -gt 0 ]] 2>/dev/null; then
                cat >> "$launch_json" << EOF
        {
            "name": "$name Beacon - PID $cl_pid",
            "type": "go",
            "request": "attach",
            "mode": "local",
            "processId": $cl_pid,
            "cwd": "$installation_dir/src/beacon-kit",
            "showLog": true
        }
EOF
            else
                cat >> "$launch_json" << EOF
        {
            "name": "$name Beacon - Not Running",
            "type": "go",
            "request": "attach",
            "mode": "local",
            "processId": 0,
            "cwd": "$installation_dir/src/beacon-kit",
            "showLog": true
        }
EOF
            fi

            # CL (Beacon-Kit) Launch Configuration - Start process in debug mode
            echo "," >> "$launch_json"
            cat >> "$launch_json" << EOF
        {
            "name": "$name Beacon - Debug Launch",
            "type": "go",
            "request": "launch",
            "mode": "exec",
            "program": "$installation_dir/src/beacon-kit/beacond-debug",
            "args": ["start", "--home", "$installation_dir/data/cl"],
            "cwd": "$installation_dir/src/beacon-kit",
            "showLog": true,
            "preLaunchTask": "Stop $name services if running",
            "stopOnEntry": true
        }
EOF

            # Get actual EL PID from systemd if service is running
            local el_pid=""
            if systemctl --user is-active "$name-el.service" >/dev/null 2>&1; then
                el_pid=$(systemctl --user show "$name-el.service" --property=MainPID --value 2>/dev/null | tr -d '\n\r ')
                log_info "Found EL PID for $name ($el_client): $el_pid"
            else
                log_info "No active EL service found for $name ($el_client)"
            fi
            
            # Additional check for reth processes if no PID was found through systemd
            if [[ "$el_client" == "reth" && ( -z "$el_pid" || "$el_pid" -eq 0 ) ]]; then
                # Try to find reth process by binary name
                local reth_pids=$(pgrep -f "bera-reth" 2>/dev/null)
                if [[ -n "$reth_pids" ]]; then
                    log_info "Found reth processes outside systemd for $name: $reth_pids"
                    # Use the first PID found
                    el_pid=$(echo "$reth_pids" | head -n1)
                    log_info "Using reth PID: $el_pid for $name"
                fi
            fi

            # EL Debug Configurations (Rust - for reth)
            if [[ "$el_client" == "reth" ]]; then
                echo "," >> "$launch_json"
                if [[ -n "$el_pid" && "$el_pid" -gt 0 ]] 2>/dev/null; then
                    cat >> "$launch_json" << EOF
        {
            "name": "$name Reth - PID $el_pid",
            "type": "lldb",
            "request": "attach",
            "pid": $el_pid,
            "cwd": "$installation_dir/src/bera-reth",
            "processName": "bera-reth",
            "displayDisassembly": "never",
            "sourceLanguages": ["rust"],
            "initCommands": [
                "settings set target.process.thread.step-avoid-libraries true",
                "settings set target.inline-breakpoint-strategy always"
            ]
        }
EOF
                else
                    cat >> "$launch_json" << EOF
        {
            "name": "$name Reth - Select Process",
            "type": "lldb",
            "request": "attach",
            "pid": "\${command:pickProcess}",
            "cwd": "$installation_dir/src/bera-reth",
            "processName": "bera-reth",
            "displayDisassembly": "never",
            "sourceLanguages": ["rust"],
            "initCommands": [
                "settings set target.process.thread.step-avoid-libraries true",
                "settings set target.inline-breakpoint-strategy always"
            ]
        }
EOF
                fi

                # Get EL args using build_el_args function
                local ports=$(get_installation_ports "$installation")
                IFS='|' read -r cl_prometheus_port el_prometheus_port <<< "$ports"
                
                local el_rpc_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_rpc_port" || echo "8545")
                local el_authrpc_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_authrpc_port" || echo "8551")
                local el_ws_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_ws_port")
                local el_p2p_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_p2p_port" || echo "30303")
                local base_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "base_port" || echo "")
                local el_ws_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_ws_port" || echo "")
                local archive_mode=$(bb_parse_toml_value "$installation_dir/installation.toml" "archive_mode" || echo "false")

                # Build EL command using arg-builder
                local el_command=$(build_el_args "reth" "$installation_dir" "$el_rpc_port" "$el_ws_port" "$el_authrpc_port" "$el_p2p_port" "$el_prometheus_port" "$installation" "$archive_mode" "0")
                
                # Extract program and args from the command
                local el_program=$(echo "$el_command" | awk '{print $1}')
                local el_args_raw=$(echo "$el_command" | cut -d' ' -f2-)
                
                # Convert space-separated args to JSON array format
                local el_args_json=""
                local first_arg=true
                while IFS= read -r arg; do
                    if [[ "$first_arg" == "true" ]]; then
                        el_args_json="\"$arg\""
                        first_arg=false
                    else
                        el_args_json="$el_args_json, \"$arg\""
                    fi
                done < <(echo "$el_args_raw" | xargs -n1)

        # Determine main.rs line for Rust entry breakpoint
        local main_rs="$installation_dir/src/bera-reth/src/main.rs"
        local main_line=$(grep -n "^[[:space:]]*fn[[:space:]]\+main[[:space:]]*\(" "$main_rs" 2>/dev/null | head -n1 | cut -d: -f1)
        if [[ -z "$main_line" ]]; then main_line=21; fi

        echo "," >> "$launch_json"
        cat >> "$launch_json" << EOF
        {
            "name": "$name Reth - Debug Launch",
            "type": "lldb",
            "request": "launch",
            "program": "$el_program",
            "args": [$el_args_json],
            "cwd": "$installation_dir/src/bera-reth",
            "preLaunchTask": "Stop $name services if running",
            "stopOnEntry": false,
            "displayDisassembly": "never",
            "sourceLanguages": ["rust"],
            "initCommands": [
                "settings set target.process.thread.step-avoid-libraries true",
                "settings set target.inline-breakpoint-strategy always",
                "break set -f src/main.rs -l $main_line"
            ]
        }
EOF
                
            # EL Debug Configurations (Go - for geth)  
            elif [[ "$el_client" == "geth" ]]; then
                echo "," >> "$launch_json"
                if [[ -n "$el_pid" && "$el_pid" -gt 0 ]] 2>/dev/null; then
                    cat >> "$launch_json" << EOF
        {
            "name": "$name Geth - PID $el_pid",
            "type": "go",
            "request": "attach", 
            "mode": "local",
            "processId": $el_pid,
            "cwd": "$installation_dir/src/bera-geth",
            "showLog": true
        }
EOF
                else
                    cat >> "$launch_json" << EOF
        {
            "name": "$name Geth - Not Running",
            "type": "go",
            "request": "attach", 
            "mode": "local",
            "processId": 0,
            "cwd": "$installation_dir/src/bera-geth",
            "showLog": true
        }
EOF
                fi

                # Get EL args using build_el_args function
                local ports=$(get_installation_ports "$installation")
                IFS='|' read -r cl_prometheus_port el_prometheus_port <<< "$ports"
                
                local el_rpc_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_rpc_port" || echo "8545")
                local el_authrpc_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_authrpc_port" || echo "8551")
                local el_ws_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_ws_port")
                local el_p2p_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_p2p_port" || echo "30303")
                local base_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "base_port" || echo "")
                local el_ws_port=$(bb_parse_toml_value "$installation_dir/installation.toml" "el_ws_port" || echo "")
                local archive_mode=$(bb_parse_toml_value "$installation_dir/installation.toml" "archive_mode" || echo "false")

                # Build EL command using arg-builder
                local el_command=$(build_el_args "geth" "$installation_dir" "$el_rpc_port" "$el_ws_port" "$el_authrpc_port" "$el_p2p_port" "$el_prometheus_port" "$installation" "$archive_mode" "0")
                
                # Extract program and args from the command
                local el_program=$(echo "$el_command" | awk '{print $1}')
                local el_args_raw=$(echo "$el_command" | cut -d' ' -f2-)
                
                # Convert space-separated args to JSON array format
                local el_args_json=""
                local first_arg=true
                while IFS= read -r arg; do
                    if [[ "$first_arg" == "true" ]]; then
                        el_args_json="\"$arg\""
                        first_arg=false
                    else
                        el_args_json="$el_args_json, \"$arg\""
                    fi
                done < <(echo "$el_args_raw" | xargs -n1)

                echo "," >> "$launch_json"
                cat >> "$launch_json" << EOF
        {
            "name": "$name Geth - Debug Launch",
            "type": "go",
            "request": "launch",
            "mode": "exec",
            "program": "$el_program",
            "args": [$el_args_json],
            "cwd": "$installation_dir/src/bera-geth",
            "showLog": true,
            "preLaunchTask": "Stop $name services if running",
            "stopOnEntry": true
        }
EOF
            fi
        fi
    done
    
    # Close configurations array and launch.json
    echo "" >> "$launch_json"
    echo "    ]" >> "$launch_json"
    echo "}" >> "$launch_json"
    
    log_info "‚úì VS Code launch configurations generated: $launch_json"
}

# Generate VS Code tasks for auto-starting services
generate_vscode_tasks() {
    log_step "Generating VS Code tasks..."
    
    # Create .vscode directory in berabox root  
    local vscode_root_dir="$VSCODE_DIR"
    bb_ensure_directory "$vscode_root_dir"
    local tasks_json="$vscode_root_dir/tasks.json"
    
    # Start tasks.json
    cat > "$tasks_json" << 'EOF'
{
    "version": "2.0.0",
    "tasks": [
EOF

    # Find all installations
    local installations=()
    for dir in "$INSTALLATIONS_DIR"/*; do
        if [[ -d "$dir" && -f "$dir/installation.toml" ]]; then
            local name=$(basename "$dir")
            installations+=("$name")
        fi
    done
    
    local first_task=true
    
    # Generate tasks for each installation
    for installation in "${installations[@]}"; do
        local info=$(get_installation_info "$installation")
        if [[ -n "$info" ]]; then
            IFS='|' read -r name chain el_client <<< "$info"
            
            # Add comma separator for subsequent tasks
            if [[ "$first_task" == "false" ]]; then
                echo "," >> "$tasks_json"
            fi
            first_task=false
            
            # Task to start CL service if stopped
            cat >> "$tasks_json" << EOF
        {
            "label": "Start $name CL if stopped",
            "type": "shell",
            "command": "systemctl",
            "args": ["--user", "start", "$name-cl.service"],
            "group": "build",
            "presentation": {
                "echo": true,
                "reveal": "silent",
                "focus": false,
                "panel": "shared"
            },
            "problemMatcher": []
        }
        ,{
            "label": "Start $name EL if stopped", 
            "type": "shell",
            "command": "systemctl",
            "args": ["--user", "start", "$name-el.service"],
            "group": "build", 
            "presentation": {
                "echo": true,
                "reveal": "silent",
                "focus": false,
                "panel": "shared"
            },
            "problemMatcher": []
        }
        ,{
            "label": "Stop $name services if running",
            "type": "shell",
            "command": "bash",
            "args": ["-c", "systemctl --user stop $name-cl.service $name-el.service 2>/dev/null || true; echo 'Services stopped for debugging'"],
            "group": "build",
            "presentation": {
                "echo": true,
                "reveal": "silent",
                "focus": false,
                "panel": "shared"
            },
            "problemMatcher": []
        }
EOF
        fi
    done
    
    # Close tasks.json
    echo "" >> "$tasks_json"
    echo "    ]" >> "$tasks_json"
    echo "}" >> "$tasks_json"
    
    log_info "‚úì VS Code tasks generated: $tasks_json"
}

# Generate Grafana dashboard using embedded templates
generate_grafana_dashboard() {
    log_step "Generating Grafana dashboard..."
    
    local dashboard_json="$GRAFANA_DIR/berabox-dashboard.json"
    
    # Discover Grafana datasource if API key is available
    local datasource_uid=""
    local grafana_url="${GRAFANA_URL:-http://localhost:3000}"
    
    if [[ -n "${GRAFANA_API_KEY:-}" ]]; then
        # Test API connectivity
        if curl -s -f -H "Authorization: Bearer $GRAFANA_API_KEY" "$grafana_url/api/health" >/dev/null 2>&1; then
            # Get default Prometheus datasource
            datasource_uid=$(curl -s -H "Authorization: Bearer $GRAFANA_API_KEY" \
                "$grafana_url/api/datasources" 2>/dev/null | \
                jq -r '.[] | select(.type=="prometheus" and .isDefault==true) | .uid // empty' 2>/dev/null)
            
            if [[ -n "$datasource_uid" ]]; then
                log_substep "Using discovered Prometheus datasource"
            else
                log_substep "No default Prometheus datasource found, creating one..."
                
                # Create Prometheus datasource using your working template
                local create_response=$(curl -s -X POST -H "Authorization: Bearer $GRAFANA_API_KEY" \
                    -H "Content-Type: application/json" \
                    -d '{"name":"prometheus","type":"prometheus","url":"http://localhost:9090","access":"proxy","isDefault":true,"jsonData":{"pdcInjected":false},"version":3,"readOnly":false}' \
                    "$grafana_url/api/datasources" 2>/dev/null)
                
                datasource_uid=$(echo "$create_response" | jq -r '.datasource.uid // empty' 2>/dev/null)
                
                if [[ -n "$datasource_uid" ]]; then
                    log_step "Created new Prometheus datasource: $datasource_uid"
                else
                    log_warn "Failed to create datasource, using fallback"
                fi
            fi
        else
            log_warn "Grafana API not accessible, using fallback datasource"
        fi
    fi
    
    # Use Python script for clean JSON generation
    if command -v python3 >/dev/null 2>&1; then
        if [[ -n "$datasource_uid" ]]; then
            log_substep "Generating dashboard with discovered datasource: $datasource_uid"
            python3 "$SCRIPT_DIR/grafana.py" "$INSTALLATIONS_DIR" "$dashboard_json" "$datasource_uid"
        else
            log_substep "Generating dashboard with fallback datasource"
            python3 "$SCRIPT_DIR/grafana.py" "$INSTALLATIONS_DIR" "$dashboard_json"
        fi
    else
        log_error "Python3 not found - cannot generate Grafana dashboard"
        return 1
    fi
    
    log_info "‚úì Grafana dashboard generated: $dashboard_json"
}





# Generate debug configurations (original functionality)
generate_debug_configs() {
    # Create debug directory structure
    create_debug_dirs
    
    # Disable problematic subproject configs
    disable_subproject_vscode_configs
    
    # Generate configurations
    generate_prometheus_config
    generate_grafana_dashboard
    generate_vscode_workspace
    generate_vscode_launch_configs
    generate_vscode_tasks

    
    # Collect and display PID summary
    log_step "Detected Process Summary"
    echo ""
    echo "üîç Process Detection Summary:"
    
    # Find all installations
    local installations=()
    for dir in "$INSTALLATIONS_DIR"/*; do
        if [[ -d "$dir" && -f "$dir/installation.toml" ]]; then
            local name=$(basename "$dir")
            installations+=("$name")
        fi
    done
    
    # Check each installation for running processes
    for installation in "${installations[@]}"; do
        local info=$(get_installation_info "$installation")
        if [[ -n "$info" ]]; then
            IFS='|' read -r name chain el_client <<< "$info"
            echo "  üìå Installation: $name ($chain)"
            
            # Check CL process
            local cl_pid=""
            if systemctl --user is-active "$name-cl.service" >/dev/null 2>&1; then
                cl_pid=$(systemctl --user show "$name-cl.service" --property=MainPID --value 2>/dev/null | tr -d '\n\r ')
                if [[ -n "$cl_pid" && "$cl_pid" -gt 0 ]]; then
                    echo "     ‚úÖ CL Process (beacon-kit): PID $cl_pid"
                else
                    echo "     ‚ùå CL Process: Service active but no PID found"
                fi
            else
                echo "     ‚ùå CL Process: Not running"
            fi
            
            # Check EL process
            local el_pid=""
            if systemctl --user is-active "$name-el.service" >/dev/null 2>&1; then
                el_pid=$(systemctl --user show "$name-el.service" --property=MainPID --value 2>/dev/null | tr -d '\n\r ')
                if [[ -n "$el_pid" && "$el_pid" -gt 0 ]]; then
                    echo "     ‚úÖ EL Process ($el_client): PID $el_pid"
                else
                    echo "     ‚ùå EL Process ($el_client): Service active but no PID found"
                fi
            else
                echo "     ‚ùå EL Process ($el_client): Not running via systemd"
                
                # Additional check for reth processes
                if [[ "$el_client" == "reth" ]]; then
                    local reth_pids=$(pgrep -f "reth-debug" 2>/dev/null)
                    if [[ -n "$reth_pids" ]]; then
                        echo "     ‚úÖ Reth processes found outside systemd: $reth_pids"
                    fi
                fi
            fi
            echo ""
        fi
    done
    
    log_info "‚úì Debug configurations generated"
    echo ""
    echo "Generated files:"
    echo "  üéØ VS Code Workspace: $BERABOX_ROOT/bb-berabox.code-workspace"
    echo "  üìä Grafana Dashboard: $GRAFANA_DIR/berabox-dashboard.json"
    echo "  üìà Prometheus Config: $PROMETHEUS_DIR/prometheus.yml"
    echo ""
    echo "Next steps:"
    echo "  1. Open workspace: code bb-berabox.code-workspace"
    echo "  2. Use F5 or Run & Debug panel to attach to CL/EL processes"
    echo "  3. Import Grafana dashboard and reconfigure Prometheus"
}

# Main execution - just generate debug configurations
main() {
    generate_debug_configs
}

# Run main function
main
